### 출처
* HTTP 완벽 가이드
___
### 개요
* [[#HTTP의 성능]]
* [[#HTTP의 커넥션 관리]]
* [[#HTTP 1.1 과 지속 커넥션]]
* [[#Content-Length and Chrome]]
* [[#파이프라인과 멱등성]]
* [[#지속 커넥션 성능 확인하기]]
___
### HTTP의 성능

<b><u>HTTP1.1 는 TCP 상단에서 구현되는 프로토콜인 만큼 하단에 위치한 TCP의 성능에 영향을 크게 받는다.</u></b> 실제로 HTTP 트랜젝션을 처리하는 부분을 생각해보면 실질적인 트랜젝션의 처리보다 **커넥션을 수립하고 데이터를 전송하는데 발생하는 오버해드가 크다**는 것을 곧장 확인할 수 있다.
![](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20Connection%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-25%20%EC%98%A4%ED%9B%84%2012.15.02.png)

이러한 오버헤드 발생의 주요 원인으로는 핸드 쉐이크, ACK 전송 지연, Slow Start, 네이글 알고리즘이 존재한다.

#### 핸드 쉐이크
핸드 쉐이크는 TCP 연결 수립의 필수적으로 존재해야 하는 단계로 **모든 커넥션이 성사되기 위해서는 이 3번의 패킷을 교환하는 절차를 반드시 진행**해야만 한다. 이에 따라 만약 **하나의 패킷에 들어갈 정도로 작은 양의 데이터를 전송하는 HTTP를 처리하는 경우여도 패킷을 반드시 3번이상 주고 받아야 하는 비효율이 발생**하게 된다.

#### 네이글 알고리즘
네이글 알고리즘은 위와 같은 문제를 해결하고자 만들어진 방법으로 **데이터가 버퍼에 어느정도 쌓일 때까지 전송을 미루다 적절한 크기에 도달하면 전송을 진행하는 방식**이다. 효율적으로 동작할 수 있으나 작은 양의 데이터만 전송할 경우 대기로 인해 오히려 딜레이가 발생하는 상황이 발생할 수 있다. 소켓 옵션을 통해 해당 기능을 비활성화 할 수있다.

#### ACK 전송 지연
TCP는 신뢰성을 보장하기 위해 데이터의 수신 이후 ACK 패킷을 전송한다. 이때 ACK 패킷 만을 전송하는 것은 데이터의 크기가 작기 때문에 커넥션을 통해 전달돼야 하는 <b><u>데이터가 추가 발생할 때까지 대기를 진행하다 ACK 패킷과 데이터를 동시에 전송하는 피기백이라는 방법이 등장</u></b>했다.

#### [[TCP 혼잡 제어#Slow Start|Slow Start]]
슬로우 스타트는 위의 링크를 참조하자.

#### [[TCP 첫 걸음#4-Way Hand Shake|Time Wait]]
 **Time Wait는 소켓의 연결이 종료될때 발생하는 상태로 특정 기간동안 해당 소켓이 사용했던 엔드 포인트의 사용을 금지하는 역할을 수행**한다. 이 경우 사용 불가한 포트의 수가 증가하게 돼 서버가 커넥션을 수립하지 못하고 대기하는 현상이 발생할 수 있다.
___
### HTTP의 커넥션 관리

앞서 언급한 문제들을 해결하고자 여러가지 방법들이 연구 됐는데 대표적인 방법이 병렬 커넥션과 지속 커넥션의 생성이다. 

* **병렬 커넥션**
병렬 커넥션은 복수 개의 커넥션을 개설해 통신을 진행하는 방식이다. 웹 사이트의 각 요소별로 별도의 커넥션을 개설해 통신을 진행한다. 순차적으로 진행할 때에 비해 속도가 개선되고 **동시에 여러 요소가 로딩 되기에 높은 응답성을 제공 하기에도 유리**하다. 하지만 병렬 커넥션의 경우 사용하는 포트의 수나 트래픽이 높은 편이기에 서버에 부하를 줄 수도 있다.

* **지속 커넥션**
지속 커넥션은 단일한 커넥션이 계속해서 여러 트랜젝션을 처리하는 것을 말한다. 이 커넥션은 클라이언트나 서버에서 명시적으로 닫기 이전까진 닫히지 않으며 여러 트랜젝션을 처리하는데 사용할 수 있다. 이러한 <span class="red red-bg">지속 커넥션을 사용하면 매 트랜젝션마다 핸드 쉐이크를 하거나 슬로우 스타트를 튜닝해야 하는 비효율을 개선할 수 있다. </span>

![500](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20Connection%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-25%20%EC%98%A4%ED%9B%84%204.37.25.png)
___
### HTTP 1.1 과 지속 커넥션

지속 커넥션과 병렬 커넥션 모두 활용하는 것이 효율적인 방법이므로 거의 모든 웹 서버와 브라우저는 해당 기능을 제공한다. 특히 **지속 커넥션의 경우 1.1 버전으로 넘어오면서 기본적인 설정 값이 돼 명시적으로 Connection 헤더를 입력하지 않는 이상 지속 커넥션을 기본 값으로 활용한다.**

만약 연결을 명시적으로 종료하고 싶을 경우 명시적으로 커넥션 헤더를 사용해야한다. 하지만 에러가 발생하거나 서버에 포트 부족 등의 문제가 발생할 경우 헤더의 여부와 상관 없이 커넥션을 종료할 수도 있다.

**커넥션이 지속되기 때문에 클라이언트는 서버의 전송이 언제 종료 되는지를 파악하기 위한 수단으로 Content-Length를 활용한다.** 
___
### 지속 커넥션과 Content-Length

[[초 간단 웹서버 만들고 실험하기]] 에서 웹서버를 만들고 크롬에서 테스트 하던중 기묘한 현상이 발생했다. 페이지가 로딩이 완료 됐음에도 크롬 로딩바가 계속 돌아가는 것이다. 로딩은 끝나질 않았고 웹서버에 어떤 요청을 보내도 해당 현상이 발생했다. 사용했던 웹서버의 메시지 전송 부분의 코드는 아래와 같다.
```python

def create_response(path: str):
    first_line = """HTTP/1.1 200 OK\r\n"""
    try:
        html = get_html(path)

    except FileNotFoundError:
        first_line = """HTTP/1.1 404 Not Found\r\n"""
        html = get_html("404.html")

    except Exception:
        first_line = """HTTP/1.1 500 Server Error\r\n"""
        html = get_html("500.html")

    finally:
        bytes_length = len(html)
        # header = f"Content-Type: text/html\r\n\r\n" no length infinite loading...
        header = f"Content-Type: text/html\r\nContent-Length:{bytes_length}\r\n\r\n" #with length finite loading...
        response_msg = f"{first_line}{header}{html}"
        return response_msg

```

초기 **컨텐츠 길이를 헤더에 넣어서 전달하지 않을 경우 전송을 진행한 후 커넥션을 곧장 닫지 않으므로 크롬에서 로딩이 완료 됐음을 확인하지 못하는 현상이 발생**했다. 이후 컨텐츠 길이를 명시한 뒤로는 해당 바이트만큼 로딩을 수행하고 페이지를 렌더링하는 것을 확인할 수 있었다.

**이러한 현상은 지속 커넥션에서 명확하게 발생하는데 단일한 커넥션으로 여러 데이터를 주고 받을 경우 통신 대상 들은 정확하게 하나의 메시지 만을 소켓에서 읽을 수 있어야 한다.** (하나의 소켓에 메시지가 복수개 쌓이기 때문) 만약 임의의 크기로 데이터를 읽을 경우 한번의 recv에서 복수 개의 데이터를 읽어버려 평생 응답을 받을 수 없는 요청이 발생하게 된다.
___
### 파이프라인과 멱등성

**파이프라인 커넥션이란 응답이 오기 이전에 연속해서 리퀘스트를 전송하는 방식**을 말한다. 파이프라인 기법을 활용 할 경우 응답 시간을 기다릴 필요 없이 곧장 복수 개의 리퀘스트를 전송해 응답 속도를 대거 높일 수 있다는 장점이 존재한다.
![500](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20Connection%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-25%20%EC%98%A4%ED%9B%84%205.11.55.png)

**파이프라인은 멱등성이 보장되지 않는 요청을 처리할 경우 문제를 유발 할 수 있다**. 예를 들어 가장 마지막에 생성된 글을 지우는 API를 10번 호출한다고 하자. 10개의 요청은 곧장 서버의 처리 대기 큐에 저장될 것이고 하나 씩 순차적으로 처리가 될 것이다. 

문제점은 처리중 에러가 발생하는 경우이다. 클라이언트는 서버가 처리 도중 뻗었기 때문에 어디서 부터 재시도를 해야하는지 명확히 파악하지 못한다. 또한 무턱대고 재시도를 진행하면 삭제가 더욱 발생하며 원치 않는 결과를 야기할 수도 있다.

> [!info]
> **파이프라인을 활용한 HTTP 요청은 멱등성을 보장하는 트랜젝션에 한해 사용하는 편이 안전하다. 멱등성이 없을 경우 복구 등에 어려움이 발생할 수 있기 때문이다.**

___
### 지속 커넥션 성능 확인하기

지속 커넥션의 장점을 머리로는 이해했으니 실제로 효과가 있는 검증하는 작업을 수행해보자. 아래에서는 [[초 간단 웹서버 만들고 실험하기]]에서 작성한 웹서버 코드를 토대로 지속 커넥션의 성능을 확인한다.

아래는 테스트를 위한 클라이언트 코드이다.
```python
def connection_not_reuse_test(try_cnt: int):
    total = 0
    for i in range(try_cnt):
        start = time.time()
        pool_ = urllib3.PoolManager() #커넥션 신규 생성
        resp = pool_.request("GET", f"{HOST}") #요청 전송
        end = time.time()
        print(f"request: {i} is done {resp} time:{end - start}")
        total += end - start
    return total


def connection_reuse_test(try_cnt):
    pool = urllib3.connection_from_url(HOST) #커넥션 생성
    total = 0
    for i in range(try_cnt):
        start = time.time()
        resp = pool.urlopen("GET", HOST) #요청 전송
        end = time.time()
        print(f"request: {i} is done {resp} time:{end - start}")
        total += end - start
    return total
```

커넥션을 재사용하는 방식의 경우 한번 커넥션을 생성한 이후로 추가적인 커넥션을 맺지 않는다. 반대로 커넥션을 재사용하지 않는 코드는 매 요청마다 커넥션을 신규로 맺는 작업을 수행한다. 결과는 다음과 같다.

```terminal
Total:31.71579909324646, avg sec: 3.171579909324646 (재사용)
Total:34.40744423866272, avg sec: 3.440744423866272 (재사용 안함)
```

**실행 결과 재사용이 약 10% 정도 빠른 속도를 보이는 것을 확인할 수 있었다. 핸드 쉐이크 과정이 생략 되며 속도가 더 빨라질 것이라 예측한 것을 실제로 확인할 수 있었다.**

실험 환경은 ngrok을 활용해 배포한 호스트 주소로 진행했다. 호스트의 위치가 일본이었는데 아마 더욱 먼 곳에 할당 됐더라면 더욱 차이가 크지 않았을까 싶다. 

>[!info]
>**지속 커넥션을 활용하면 실제로 빨라진다.**

___

